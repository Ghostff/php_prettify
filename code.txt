  /*
    * make all comments italic
    */
    private static $italic_comment = true;
    /*
    * prevents user defined function from being highlighted
    */
    private static $user_func_highlight = false;
    
    
    
    /*
    * update an existing property(color) value
    *
    * returns null
    * @param property(color) to update
    * @param new property value
    */
    public static function set($prop_name, $values)
    {
        self::$$prop_name = $values;
    }
    
    /*
    * searches and strips out any code styling 
    * inside multi line comment or qoute block
    *
    * returns string
    * @param string to search
    */
    private static function stripTags($code)
    {
        $code .= '<script>
            var p = document.getElementsByClassName(\"stp\");
            for(i = 0; i < p.length; i++) {
                p[i].innerHTML = 
                p[i].innerHTML.replace(/<(?!br\s*\/?)[^>]+>/g, \"\");
            }
        </script>';
        if (self::$allow_esc) {
            $code = str_replace(array("\'", '\"'), array("'", '"'), $code);
        }
        return $code;
    }
    
    /*
    * Assigns a tag and style to a particular string
    *
    * returns string
    * @param string to be styled
    * @param color to be assigned
    */
    private static function color($string, $color = null, $font = null)
    {
        $cls = '~SM';
        if (substr($color, 0, 1) == '#') {
            $color = str_replace('#', '~~', $color);    
        }
        if ($font == 'cls') {
            $font = null;
            $cls = '~CSM';
        }
        elseif ($font == 'clf') {
            $font = ';~italic';
            $cls = '~CKM_T';
        }
        return '~SO'. $color . $font . $cls . $string . '~SC';
    }
    
    /*
    * add slashes to qoute inside comment or
    * qoute box
    *
    * returns string
    */
    private static function addSlashes($string)
    {
        preg_replace_callback(
            self::$mcm_arr,
            function ($matches) use (&$string) {
                $string = str_replace(
                    $matches[0],
                    self::color(addslashes($matches[0]),
                    self::$com, 'clf'),
                    $string
                );
            },
            $string
        );
		
        preg_replace_callback(
            self::$qot_arr,
            function ($matches) use (&$string) {
                $string = str_replace(
                    $matches[0],
                    self::color(str_replace(
                        array('/', '#'),
                        array('~~/', '~~#'),
                        $matches[0]),
                        self::$qot, 'cls'),
                    $string
                );
            },
            $string
        );
		
        preg_replace_callback(
            self::$com_arr,
            function ($matches) use (&$string) {
                $string = str_replace(
                    $matches[0],
                    self::color(addslashes($matches[0]),
                    self::$com, 'clf'),
                    $string
                );
            },
            $string
			
        );
		
        return $string;
    }
    
    /*
    * Perform a regular expression search and replace
    *
    * returns string
    * @param The pattern to search for. It can be 
    * either a string or an array with strings
    *
    * @param A callback that will be called and passed an array of 
    * matched elements in the subject string. The callback 
    * should return the replacement string. This is the 
    * callback signature:
    * ----OR
    * @param The string or an array with strings to replace
    *
    * @param The string or an array with strings to 
    * search and replace
    */
    private static function PR($pattern, $callrepl, $subject)
    {
        $pattern = trim(preg_replace('/\s\s+/', '', $pattern));
        return preg_replace($pattern, $callrepl, $subject);
    }